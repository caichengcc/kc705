<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>xyl_oslib_common: Functional description</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">xyl_oslib_common
   &#160;<span id="projectnumber">1.06.a</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Functional description </div>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="p3s1"></a>
General idea</h2>
<p>Device driver for some specific hardware is usually written multiple times for each operating system and each physical bus used to access the hardware.</p>
<p>For example for UART and I2C hardware blocks on two different operating systems and accessible over two different busses you will have following 8 variations. Each of them requiring a separate driver: </p>
<ul>
<li>UART, Linux OS, PCI bus </li>
<li>UART, Linux OS, USB bus </li>
<li>UART, WINCE OS, PCI bus </li>
<li>UART, WINCE OS, USB bus </li>
<li>I2C, Linux OS, PCI bus </li>
<li>I2C, Linux OS, USB bus </li>
<li>I2C, WINCE OS, PCI bus </li>
<li>I2C, WINCE OS, USB bus</li>
</ul>
<p>Since driver writing is expensive process we try to isolate common elements in drivers and reduce the amount of code and effort while to minimal degree.</p>
<p>In the example above following 10 parts can be isolated as separate modules: </p>
<ul>
<li>1. Linux I2C driver </li>
<li>2. Linux UART driver </li>
<li>3. WINCE I2C driver </li>
<li>4. WINCE UART driver </li>
<li>5. I2C generic part of driver </li>
<li>6. UART generic part of driver </li>
<li>7. WINCE PCI BUS interface </li>
<li>8. WINCE USB BUS interface </li>
<li>9. Linux PCI BUS interface </li>
<li>10.Linux USB BUS interface</li>
</ul>
<p>By partioning the drivers in such a way we at firs end up with more modules then before. Fortunatelly some of this modules are reusable and this adds value:</p>
<p>1. - 4. are the OS dependant drivers (upper driver layer) - this layer if driver has to be written for each new driver so it is not reusable but advantage is that it is actually only a thin wrapper</p>
<p>5. and 6. are the generic hardware drivers. They describe the hardware functionality. Generic drivers for this hardware can be reused for each new port of driver to some new OS/BUS combination.</p>
<p>7. and 8. are WINCE implementation of the different BUS access interfaces. This part is common for all drivers that will be written on WINE and can be reused.</p>
<p>9. and 10. are Linux implementation of the different BUS access interfaces. This part is common for all drivers that will be written on WINE and can be reused.</p>
<h2><a class="anchor" id="p3s2"></a>
Layered driver architecture</h2>
<p>The driver layered architecture is following:<br/>
 <b> 1. OS driver (OSDRV) </b><br/>
 OSDRV is the OS dependant part of driver. It is made specificaly for the targeted OS and the targeted BUS ( e.g. Linux driver for UART over USB). Usually the OSDRV is just a thin code wrapper required by OS for particualr type of driver. Main driver functionality should reside in next layer.</p>
<p><b> 2. Generic driver (GENDRV) </b> <br/>
 GENDRV is the generic part of the driver that describes the hardware functionality (e.g. generic UART driver would define UART registers and some common functions for usuall UART operation). Generic driver is completely independent on the OS or the BUS.</p>
<p><b> 3. OS library (OSLIB) </b><br/>
 OSLIB is library written for a specific OS system. This library provides a common interface which generic drivers can use on any OS / BUS combination. It provides the interface to the specific OS types, synchronisation mechanisms, bus access mechanisms and other. <br/>
 </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Driver layers are separated only when they are in the source form. They are compiled and linked into a single driver binary. <br/>
 <br/>
 With such layered architecture we minimize the amount of work required when writting driver for new OS/BUS combination:<ul>
<li>OSLIB has to be written only once for each OS.</li>
<li>GENDRV is part of driver that has to be written only once for given hardware.</li>
<li>OSDRV has to be written each time we implement a new driver for some OS/BUS.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="p3s3"></a>
Oslib interface</h2>
<p>Xylon OS library (xyl_oslib) provides interface to all of the OS specific functions that are required by a driver. By using this library generic driver (GENDRV) can be made completely OS and BUS independent.</p>
<p>Following interface groups are provided by the oslib: </p>
<dl class="user"><dt><b>Os types</b></dt><dd>It provides typical types (pointers, unsigned 8,16,32). See <a class="el" href="_oslib_types_8h.html">Oslibtypes.h</a> </dd></dl>
<dl class="user"><dt><b>OS debug </b></dt><dd>Provides debug macros for printing, asserting. See <a class="el" href="_oslib_debug_8h.html">OslibDebug.h</a> </dd></dl>
<dl class="user"><dt><b>OS hw access </b></dt><dd>Provides access functions to hardware register. Hardware access is independant of the bus type. <br/>
 Bus independancy is obtained using the pointer to struct _OsRegRangeT which is argument to all access functions. <br/>
 Functions OsRegRangeInit and OsRegRangeDeinit provide init deinit interface for the bus access descriptor. OsHwResourceT represents the hardware resource input structure<br/>
 struct _OsRegRangeT represents the OSLIB descriptor for accessing hardware registers. See <a class="el" href="_oslib_hw_access_8h.html">OslibHwAccess.h</a> <br/>
<ul>
<li>note: for documentation of structures struct _OsRegRangeT and OsHwResourceT look in the oslib implementation document (e.g. UM_xyl_oslib_linux_1_0_0) </li>
</ul>
</dd></dl>
<dl class="user"><dt><b>OS spinlock </b></dt><dd>Provides interface for spinlocks, see <a class="el" href="_oslib_spin_lock_8h.html">OslibSpinLock.h</a> </dd></dl>
<dl class="user"><dt><b>OS misc </b></dt><dd>Provides interface for miscellaneous OS functions <a class="el" href="_oslib_misc_8h.html">OslibMisc.h</a> </dd></dl>
</div></div>


<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 16 2012 13:41:44 for xyl_oslib_common by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
